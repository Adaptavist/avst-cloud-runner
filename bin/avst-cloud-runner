#!/usr/bin/env ruby 
# Copyright 2015 Adaptavist.com Ltd.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

require 'avst-cloud'
require 'hiera_loader'
require 'docopt'
require 'colorize'
require 'json'
require "net/http"
require "uri"
require 'yaml'
require 'confluence_reporter'

avst_cloud_base ="#{File.expand_path("../../", __FILE__)}"

# This heredoc describes the options that the application will recognise and parse: https://github.com/docopt/docopt.rb
doc = <<DOCOPT
Adaptavist Cloud Runner

Usage:
  avst-cloud-runner <server-name> (all|start|bootstrap|provision|clean) [-f] [-c CONFIG] [-x CUSTOM] [-s SERVER_CONFIG_URL]
                               [--no-report] [-u SERVER_CONFIG_URL_USERNAME] [-p SERVER_CONFIG_URL_PASSWORD]
  avst-cloud-runner <server-name> (destroy|stop) [-f] [-c CONFIG] [-x CUSTOM] [-s SERVER_CONFIG_URL] [--no-report]
                             [-k | --remove-known-hosts] [-u SERVER_CONFIG_URL_USERNAME] [-p SERVER_CONFIG_URL_PASSWORD]
  avst-cloud-runner <server-name> (test-config|status) [-f] [-c CONFIG] [-x CUSTOM] [-s SERVER_CONFIG_URL] [-u SERVER_CONFIG_URL_USERNAME] [-p SERVER_CONFIG_URL_PASSWORD]
  avst-cloud-runner (all|start|stop|destroy|bootstrap|provision|clean) [-f] [-x CUSTOM] [-s SERVER_CONFIG_URL] [--no-report] [-u SERVER_CONFIG_URL_USERNAME] [-p SERVER_CONFIG_URL_PASSWORD]
  avst-cloud-runner -h | --help

Options:
  -h --help                          Show this screen.
  -f --force                         Don't confirm settings [default: false]
  --no-report                        Do not report event to Confluence [default: false]
  -k --remove-known-hosts            Delete entry from ~/.ssh/known_hosts file [default: false]
  -c CONFIG --hiera_config CONFIG    Hiera config file
  -x CUSTOM --custom_config CUSTOM   Contains JSON that will be available to hiera to configure avst-cloud and passed as facts to created server
  -s SERVER_CONFIG_URL --server_config_url SERVER_CONFIG_URL url to retrieve avst-cloud configuration for the server
  -u SERVER_CONFIG_URL_USERNAME --server_config_url_username SERVER_CONFIG_URL_USERNAME username to use to retireve avst-cloud configuration for the server
  -p SERVER_CONFIG_URL_PASSWORD --server_config_url_password SERVER_CONFIG_URL_PASSWORD password for username to retrieve avst-cloud configuration for the server
Arguments:
  server-name   Must be in the format: {customer_shortcode}-{env}{server_id}
                The customer_shortcode and environment may contain
                alphanumerics and underscores.

Commands:
  all           Runs the following commands: start, bootstrap, provision
  start         Create a new server on the provider. Does not bootstrap or
                provision the machine
  bootstrap     Installs required dependencies for provisioning. (RVM, Ruby,
                Puppet, Git, Hiera, Eyaml...)
                This MUST be run before the provision command
  provision     Provisions server using Puppet and Capistrano based on the
                repository specified in hiera
  clean         Runs clean commands on the server, by default gathers system stats. 
                Can pass custom commands to run. 
  status        Checks and prints a servers status
  stop          Shuts down a server but does not destroy it. (Not available
                for Rackspace provider)
  destroy       Shuts down a server and destroys it
  test-config   Checks and prints configuration
DOCOPT

def get_user_input(prompt)
    STDOUT.print "#{prompt}: "
    STDIN.gets.chomp
end

def confirm(message, force)
    confirmed = false
    if force
        confirmed = true
    else
        if get_user_input("#{message}\nAre you sure? ('Y')").upcase == "Y"
            confirmed = true
        end
    end
    confirmed
end

def remove_known_hosts_entry(matching, remove_it=true)
    if remove_it
        `sed -i.bck '/#{matching}/d' ~/.ssh/known_hosts`
    end
end

def create_aws_server(connection, server_name)
    
    cloud_operating_system = @conf.get_config("cloud_operating_system")

    avst_cloud_config_service = @conf.get_config("avst_cloud_config_service", false) || @global_config['avst_cloud_config_service']
    avst_cloud_config_service_username = @conf.get_config("avst_cloud_config_service_username", false) || @global_config['avst_cloud_config_service_username']
    avst_cloud_config_service_password = @conf.get_config("avst_cloud_config_service_password", false) || @global_config['avst_cloud_config_service_password']
    avst_cloud_config_file = @conf.get_config("avst_cloud_config_file", false)

    hdd_device_path = @conf.get_config("hdd_device_path", false)
    ami_image_id = @conf.get_config("ami_image_id", false)

    unless hdd_device_path and ami_image_id
        if avst_cloud_config_service
            provider = connection.provider
            region = connection.region
            # def get_server_image_template(provider, operating_system, region)
            url = URI.parse("#{avst_cloud_config_service}/server_identifier")
            params = {"provider" => provider, "region" => region, "operating_system" => cloud_operating_system}

            req = Net::HTTP::Get.new(url.request_uri)
            req.set_form_data( params )
            # if username and pass try with auth
            if (avst_cloud_config_service_username && avst_cloud_config_service_password)
                # setup auth
                req.basic_auth avst_cloud_config_service_username, avst_cloud_config_service_password
            end
            use_ssl = false
            if url.instance_of? URI::HTTPS
                use_ssl = true
            end
            begin
                response = Net::HTTP.start(url.host, url.port, use_ssl: use_ssl) { |http| http.request(req) }
                case response
                when Net::HTTPSuccess     then response.body
                else
                    abort "#{response.body} #{response.code.to_s}"
                end
            rescue Errno::ECONNREFUSED
                abort "ERROR: Connection refused while trying to connect to #{avst_cloud_config_service}/server_identifier"
            end
            puts response.body.inspect
            resp = JSON.parse(response.body)
            ami_image_id = ami_image_id || resp['image_name']
            hdd_device_path = root_device_path || resp['root_device_path']
        elsif avst_cloud_config_file
            provider = connection.provider
            region = connection.region
            file_config = YAML.load_file("#{avst_cloud_config_file}")
            if (file_config[provider][region] and file_config[provider][region] and file_config[provider][region][cloud_operating_system] and file_config[provider][region][cloud_operating_system]['image_name'])
                ami_image_id = ami_image_id || file_config[provider][region][cloud_operating_system]['image_name']
            end
            if (file_config[provider][region] and file_config[provider][region] and file_config[provider][region][cloud_operating_system] and file_config[provider][region][cloud_operating_system]['root_device_path'])
                hdd_device_path = hdd_device_path || file_config[provider][region][cloud_operating_system]['root_device_path']
            end
        end
    end
    
    mould                  = @conf.get_config("mould")
    key_name               = @conf.get_config("aws_key_name")
    ssh_key                = @conf.get_config("aws_ssh_key") 
    subnet_id              = @conf.get_config("aws_subnet_id")
    security_group_ids     = @conf.get_config("aws_security_group_ids")
    ebs_size               = @conf.get_config("aws_ebs_size", false)
    availability_zone      = @conf.get_config("aws_availability_zone")

    connection.create_server(server_name, mould, cloud_operating_system, key_name, ssh_key, subnet_id, security_group_ids, ebs_size, hdd_device_path, ami_image_id, availability_zone)
end

def bootstrap_server(server, force)
    server_name = server.server_name
    # domain and fqdn are overwritten for Vagrant below
    domain            = @conf.get_config("domain")
    fqdn              = "#{server_name}.#{domain}"
    
    as_user           = @conf.get_config('root_user', false) || server.access_user
    puppet_runner     = @conf.get_config('puppet_runner', false)

    eyaml_private_key = @conf.hiera.config[:eyaml][:pkcs7_private_key]
    eyaml_public_key  = @conf.hiera.config[:eyaml][:pkcs7_public_key]

    unless File.exists?(eyaml_private_key) && File.exists?(eyaml_public_key)
        abort("ERROR: Please ensure the eyaml public and private keys are configured and exist".red)
    end

    os                 = @conf.get_config('cloud_operating_system')
    bootstrap_template = @conf.get_config("bootstrap_template", false)
    
    # By default load file from config/bootstrap
    default_bootstrap_script = "#{File.expand_path("../../", __FILE__)}/config/bootstrap/#{os}.yaml.erb"
    bootstrap_file     = bootstrap_template || default_bootstrap_script

    bootstrap_tempalte = File.read(bootstrap_file)
    if bootstrap_tempalte
        bootstrap_yaml = YAML.load(ERB.new(bootstrap_tempalte).result(binding))
    else
        bootstrap_yaml = {}
    end

    bootstrap_pre_upload_commands = @conf.get_config("bootstrap_pre_upload_commands", false)
    pre_upload_commands = bootstrap_pre_upload_commands || bootstrap_yaml['pre_upload_commands'] || []
    
    bootstrap_uploads = @conf.get_config("bootstrap_uploads", false)

    custom_file_uploads = bootstrap_uploads || bootstrap_yaml['custom_file_uploads'] || {}

    bootstrap_post_upload_commands = @conf.get_config("bootstrap_pre_upload_commands", false)
    post_upload_commands = bootstrap_post_upload_commands || bootstrap_yaml['post_upload_commands'] || []
    
    remote_server_debug = false
    debug_structured_log = false
    server.bootstrap(pre_upload_commands, custom_file_uploads, post_upload_commands, remote_server_debug, debug_structured_log)
end


def provision_server(server, server_tmp_folder)
    # Provision params
    git    = @conf.get_config("git")
    branch = @conf.get_config("branch", false)
    reference = @conf.get_config("reference", false)
    puppet_runner = @conf.get_config("puppet_runner", false)
    puppet_runner_prepare = @conf.get_config("puppet_runner_prepare", false)
    custom_provisioning_commands = @conf.get_config("custom_provisioning_commands", false)
    destination_folder = nil
    server.provision(git, branch, server_tmp_folder, reference, custom_provisioning_commands, puppet_runner, puppet_runner_prepare, destination_folder)
end

def post_provision_cleanup(server, server_tmp_folder)
    os = @conf.get_config('cloud_operating_system')
    custom_cleanup_commands = @conf.get_config('custom_cleanup_commands')
    remote_server_debug = true
    server.post_provisioning_cleanup(custom_cleanup_commands, os, remote_server_debug, server_tmp_folder)
end

def connect_to_server(connection, server_name)
    os = @conf.get_config('cloud_operating_system')
    provider = @conf.get_config('provider')
    case provider
    when "aws"
        # defaults based on os
        root_user = @conf.get_config('root_user', false) || nil
        root_password = @conf.get_config('aws_ssh_key')
    else
        raise "ERROR: Currently supported providers are: aws.".red
    end
    server = connection.server(server_name, root_user, root_password, os)
end

def test_config(server_name)
    provider = @conf.get_config('provider')
    splitted            = server_name.split("-")
    customer_short_code = splitted[0]
    env                 = splitted[1].gsub(/\d+/, '')
    server_number       = splitted[1].gsub(/[^\d]+/, '')

    case provider
    when 'aws'
        
        puts "Called test-config for #{server_name}".green
        puts "Provider:            #{@conf.get_config('provider')}"
        puts "Provider user:       #{@conf.get_config('provider_username')}"
        puts "Provider pass:       #{@conf.get_config('provider_password')}"
        puts "eyaml private key:   #{@conf.hiera.config[:eyaml][:pkcs7_private_key]}"
        puts "eyaml public key:    #{@conf.hiera.config[:eyaml][:pkcs7_public_key]}"
        puts "Connection SSH key   #{@conf.get_config('aws_ssh_key')}"
        puts "Domain:              #{@conf.get_config('domain', false)}"
        puts "Customer short code: #{customer_short_code}"
        puts "Environment:         #{env}"
        puts "Mould:               #{@conf.get_config('mould')}"
        puts "Operating system:    #{@conf.get_config('cloud_operating_system')}"
        puts "Region:              #{@conf.get_config('region')}"
        puts "Subnet id:           #{@conf.get_config("aws_subnet_id", false)}"
        puts "Security group ids:  #{@conf.get_config("aws_security_group_ids", false)}"
        puts "Availability zone:   #{@conf.get_config("aws_availability_zone", false)}"
        puts "Git repo:            #{@conf.get_config('git', false)}"
        puts "Branch:              #{@conf.get_config('branch', false)}"
        puts "Tag reference:       #{@conf.get_config('reference', false)}"
        puts "AWS ebs size:        #{@conf.get_config('ebs_size', false)} G"
    else
        raise "ERROR: Currently supported providers are: aws.".red
    end
end

start_time = Time.now

begin
  options = Docopt::docopt(doc)
rescue Docopt::Exit => e
  abort(e.message)
end

@global_config = {}
if File.exists? ("#{ENV['HOME']}/.avst-cloud.yaml")
    @global_config = YAML.load(File.read("#{ENV['HOME']}/.avst-cloud.yaml"))
end

server_config_url = options["--server_config_url"]
if server_config_url =~ URI::regexp
    # in case it is url download the config
    url = URI.parse("#{server_config_url}")
    req = Net::HTTP::Get.new(url.request_uri)
    server_config_username = options["--server_config_url_username"] || @global_config['server_config_url_username']
    server_config_password = options["--server_config_url_password"] || @global_config['server_config_url_password']
    if server_config_username and server_config_password
        # setup auth
        req.basic_auth server_config_username, server_config_password
    else
        puts "service config provided but --server_config_url_username and --server_config_url_password missing, trying withouth auth."
    end

    use_ssl = false
    if url.instance_of? URI::HTTPS
        use_ssl = true
    end
    response = Net::HTTP.start(url.host, url.port, use_ssl: use_ssl) { |http| http.request(req) }

    # we expect yaml file that represents avst-cloud configuration
    # store it to custom_config
    
    if response.kind_of? Net::HTTPSuccess and response.body != ""
        begin
            SERVER_CONFIG_yaml = YAML.load(response.body)
        rescue YAML::ParserError => e
            abort("ERROR: Passed config is not a valid yaml. #{response.body}")
        end
    else
        abort("Configuration via service not found: #{server_config_url}")
    end
end

custom_config = options["--custom_config"]
# create custom config in case it is defined
if custom_config
    begin
        custom_config = JSON.parse(custom_config)
    rescue JSON::ParserError => e
        abort("ERROR: Passed config is not a valid json. #{custom_config}")
    end
    server_name = custom_config['server_name']
    unless server_name and (/^\w+-\w+\d+$/ =~ server_name.downcase)
       puts("WARN: Valid server_name not provided in custom_config, Will try options... See the help for details".yellow)    
    else
        splitted = server_name.split("-")
        custom_config['client'] = splitted[0]
    end
    # for avst-cloud hiera config
    if SERVER_CONFIG_yaml
        SERVER_CONFIG_yaml = SERVER_CONFIG_yaml.merge custom_config
    else
        SERVER_CONFIG_yaml = custom_config
    end
end

if SERVER_CONFIG_yaml
    File.open('config/hiera/custom_config.yaml', 'w') {|f| f.write SERVER_CONFIG_yaml.to_yaml }
    # as custom facts that will be passed to server 
    # must pass client, mapped_hostname, host_<application_type> or puppet will fail
    File.open('config/custom_system_config/environments/production/modules/hosts/facts.d/facts.yaml', 'w') {|f| f.write SERVER_CONFIG_yaml.to_yaml }
end

force              = options["--force"]
do_not_log         = options["--no-report"]
remove_known_hosts = options["--remove-known-hosts"]
hiera_config       = options["--hiera_config"]

unless server_name
    # Validation
    unless options["<server-name>"] and (/^\w+-\w+\d+$/ =~ options["<server-name>"].downcase)
        abort("ERROR: Please provide a valid server name. See the help for details".red)
    end
    server_name = options["<server-name>"].downcase
end

# Configuration checking
splitted            = server_name.split("-")
customer_short_code = splitted[0]
env                 = splitted[1].gsub(/\d+/, '')
server_number       = splitted[1].gsub(/[^\d]+/, '')

scope = {
  "::server_name"         => server_name,
  "::env"                 => env,
  "::customer_short_code" => customer_short_code
}

# create fully qualified hiera.yaml based on template, to be able to refer to config/hiera
unless hiera_config
    hiera_config = "#{avst_cloud_base}/hiera.yaml"
    hiera_config_template = File.read("#{avst_cloud_base}/templates/hiera.yaml.erb")
    File.open("#{hiera_config}", 'w') do |f|
        f.write ERB.new(hiera_config_template).result(binding)
    end
end

@conf = HieraLoader.new(scope, hiera_config)

# parse conf from hiera
provider = @conf.get_config("provider").downcase

do_not_log = do_not_log || ( @conf.get_config("no_report", false) == 'true')
unless do_not_log
    puts "Setting confluence logger as default logger".green
    conf_base_url        = @conf.get_config("confluence_url", false) || @global_config['confluence_url']
    conf_user            = @conf.get_config("confluence_user", false) || @global_config['confluence_user']
    conf_pass            = @conf.get_config("confluence_access_password", false) || @global_config['confluence_access_password']
    conf_space           = @conf.get_config("confluence_space", false) || @global_config['confluence_space']
    conf_parrent_page_id = @conf.get_config("confluence_parent_page_id", false) || @global_config['confluence_parent_page_id']
    unless conf_base_url and conf_user and conf_pass and conf_space and conf_parrent_page_id
        raise "Please provide confluence reporter configuration. Provided: URL: #{conf_base_url} User: #{conf_user} Pass: #{conf_pass} Space #{conf_space} Page_id #{conf_parrent_page_id}"
    end
    confl_logger = ConfluenceReporter::Reporter.new(conf_base_url, conf_user, conf_pass) 
end

case provider
when "aws"
    provider_user = @conf.get_config("provider_username", false) || @global_config['provider_username']
    provider_pass = @conf.get_config("provider_password", false) || @global_config['provider_password']
    region = @conf.get_config("region", false) || @global_config['region']
    unless provider_user and provider_pass and region
        raise "Please provide provider credentials and region. Provided: User #{provider_user}, Pass #{provider_pass}, Region #{region}"
    end
    connection = AvstCloud::AwsConnection.new(provider_user, provider_pass, region)
    AvstCloud::AwsConnection.logger = confl_logger
    AvstCloud::AwsServer.logger = confl_logger
    AvstCloud::SshCommandTask.logger = confl_logger
    AvstCloud::ScpTask.logger = confl_logger
else
    raise "ERROR: Currently supported providers are: aws.".red
end

has_errors=false
begin
    if options['all']
        puts "Called all".green
        test_config(server_name)
        confirmed = confirm("Are you sure you want to create server #{server_name}?", force)
        if confirmed
            server = create_aws_server(connection, server_name)
            bootstrap_server(server, force)
            avst_cloud_tmp_folder = @conf.get_config("avst_cloud_tmp_folder", false) || "/tmp/avst_cloud_tmp_#{Time.now.to_i}"
            provision_server(server, avst_cloud_tmp_folder)
            skip_clean = @conf.get_config("skip_clean", false) || false
            unless skip_clean
                post_provision_cleanup(server, server_tmp_folder)
            end
        else
            puts "Not creating server, you have to confirm.".yellow
        end 
    elsif options['clean']
        puts "Called clean".green
        avst_cloud_tmp_folder = @conf.get_config("avst_cloud_tmp_folder", false) || "/tmp/avst_cloud_tmp_#{Time.now.to_i}"
        # In case it is default with timestamp remove all
        if (avst_cloud_tmp_folder =~ /\/tmp\/avst_cloud_tmp_/)
            avst_cloud_tmp_folder = "/tmp/avst_cloud_tmp_*"
        end
        server = connect_to_server(connection, server_name)
        post_provision_cleanup(server, avst_cloud_tmp_folder)
        puts "Clean done".green
    elsif options['test-config']
        do_not_log = true
        test_config(server_name)
    elsif options['start']
        puts "Called start".green
        confirmed = confirm("Are you sure you want to create/start server #{server_name}?", force)
        if confirmed
            server = create_aws_server(connection, server_name)
        else
            puts "Not starting server.".yellow
        end
    elsif options['stop']
        puts "Called stop".green
        confirmed = confirm("Are you sure you want to stop server #{server_name}?", force)
        if confirmed
            server = connect_to_server(connection, server_name)
            server.stop
            server_ip_addr = server.ip_address
            remove_known_hosts_entry(server_ip_addr, remove_known_hosts)
        else
            puts "Not stopping server.".yellow
        end
    elsif options['status']
        do_not_log = true
        puts "Called status".green
        connection.server_status(server_name)
    elsif options['destroy']
        puts "Called destroy".green
        confirmed = confirm("Are you sure you want to destroy server #{server_name}?", force)
        if confirmed 
            server = connect_to_server(connection, server_name)
            server.destroy
            server_ip_addr = server.ip_address
            remove_known_hosts_entry(server_ip_addr, remove_known_hosts)
        else
            puts "Not destroying server as you did not confirm it.".yellow
        end
    elsif options['provision']
        puts "Called provision".green
        server = connect_to_server(connection, server_name)
        avst_cloud_tmp_folder = @conf.get_config("avst_cloud_tmp_folder", false) || "/tmp/avst_cloud_tmp_#{Time.now.to_i}"
        provision_server(server, avst_cloud_tmp_folder)
    elsif options['bootstrap']
        puts "Called bootstrap".green
        server = connect_to_server(connection, server_name)
        bootstrap_server(server, force)
        puts "Bootstrap done".green
    elsif options['find_server']
        do_not_log = true
        puts "Called find".green
        connection.find_server(server_name).inspect
    else
        do_not_log = true
        abort("ERROR: Please provide a valid command".red)
    end

    if SERVER_CONFIG_yaml
        # in case custom config was created clean the file afterwards
        File.open('config/hiera/custom_config.yaml', 'w') {|f| f.write "".to_yaml }
    end

# In case something went wrong on the way
rescue Exception => e
    message = e.message.force_encoding("utf-8")
    connection.logger.error("Something went wrong: #{message}")
    e.backtrace.each do |err|
        connection.logger.error(err)
    end
    has_errors=true
end

unless do_not_log
    puts "Reporting progress".green
    begin
        connection.logger.report_event(server_name, conf_parrent_page_id, conf_space)
    rescue Exception => e
        puts e.message.yellow
    end
end

if has_errors
    abort "Process failed with error: #{message}".red
end

time_taken = ((Time.now - start_time) / 60).round(2)
puts "Finished in #{time_taken} minutes".green
