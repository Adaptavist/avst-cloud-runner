#!/usr/bin/env ruby 
# Copyright 2015 Adaptavist.com Ltd.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

require 'avst-cloud'
require 'hiera_loader'
require 'docopt'
require 'colorize'
require 'json'
require "net/http"
require "uri"
require 'yaml'
require 'confluence_reporter'
require 'etc'

avst_cloud_base ="#{File.expand_path("../../", __FILE__)}"


# This heredoc describes the options that the application will recognise and parse: https://github.com/docopt/docopt.rb
doc = <<DOCOPT
Adaptavist Cloud Runner

Usage:
  avst-cloud-runner <server-name> (all|create|start|bootstrap|provision|clean) [-f] [-c CONFIG] [-x CUSTOM] [-s SERVER_CONFIG_URL]
                               [--no-report] [-u SERVER_CONFIG_URL_USERNAME] [-p SERVER_CONFIG_URL_PASSWORD] [--show_passwords] [--dry] [--config_dir RUNNER_CONFIG_DIRECTORY]
  avst-cloud-runner <server-name> (destroy|stop) [-f] [-c CONFIG] [-x CUSTOM] [-s SERVER_CONFIG_URL] [--no-report] 
                             [-k | --remove-known-hosts] [-u SERVER_CONFIG_URL_USERNAME] [-p SERVER_CONFIG_URL_PASSWORD] [--show_passwords] [--config_dir RUNNER_CONFIG_DIRECTORY]
  avst-cloud-runner <server-name> (test-config|status) [-f] [-c CONFIG] [-x CUSTOM] [-s SERVER_CONFIG_URL] [-u SERVER_CONFIG_URL_USERNAME] [-p SERVER_CONFIG_URL_PASSWORD] [--show_passwords] [--config_dir RUNNER_CONFIG_DIRECTORY]
  avst-cloud-runner (all|create|start|stop|destroy|bootstrap|provision|clean) [-f] [-x CUSTOM] [-s SERVER_CONFIG_URL] [--no-report] [-u SERVER_CONFIG_URL_USERNAME] [-p SERVER_CONFIG_URL_PASSWORD] [--show_passwords] [--dry] [--config_dir RUNNER_CONFIG_DIRECTORY]
  avst-cloud-runner -h | --help

Options:
  -h --help                          Show this screen.
  -f --force                         Don't confirm settings [default: false]
  --no-report                        Do not report event to Confluence [default: false]
  -k --remove-known-hosts            Delete entry from ~/.ssh/known_hosts file [default: false]
  -c CONFIG --hiera_config CONFIG    Hiera config file
  -x CUSTOM --custom_config CUSTOM   Contains JSON that will be available to hiera to configure avst-cloud and passed as facts to created server
  -s SERVER_CONFIG_URL --server_config_url SERVER_CONFIG_URL url to retrieve avst-cloud configuration for the server
  -u SERVER_CONFIG_URL_USERNAME --server_config_url_username SERVER_CONFIG_URL_USERNAME username to use to retireve avst-cloud configuration for the server
  -p SERVER_CONFIG_URL_PASSWORD --server_config_url_password SERVER_CONFIG_URL_PASSWORD password for username to retrieve avst-cloud configuration for the server
  --show_passwords                   Display passwords in log output, otherwise they are masked with stars
  --dry                              Prints out commands to be executed in bootstrap and post provision phase, does not execute them, use with bootstrap and clean command
  --config_dir RUNNER_CONFIG_DIRECTORY Sets the configuration directory base to be used when genrating hiera.yaml, if not set defaults to the application base dir
Arguments:
  server-name   Must be in the format: {customer_shortcode}-{env}{server_id}
                The customer_shortcode and environment may contain
                alphanumerics and underscores.

Commands:
  all           Runs the following commands: start, bootstrap, provision
  create        Creates a server, is stopped will start it. Without bootstrap os provision
  start         Start a server on the provider. Does not bootstrap or
                provision the machine
  bootstrap     Installs required dependencies for provisioning. (RVM, Ruby,
                Puppet, Git, Hiera, Eyaml...)
                This MUST be run before the provision command
  provision     Provisions server using Puppet and Capistrano based on the
                repository specified in hiera
  clean         Runs clean commands on the server, by default gathers system stats. 
                Can pass custom commands to run. 
  status        Checks and prints a servers status
  stop          Shuts down a server but does not destroy it. (Not available
                for Rackspace provider)
  destroy       Shuts down a server and destroys it
  test-config   Checks and prints configuration
DOCOPT

def get_user_input(prompt)
    STDOUT.print "#{prompt}: "
    STDIN.gets.chomp
end

def confirm(message, force)
    confirmed = false
    if force
        confirmed = true
    else
        if get_user_input("#{message}\nAre you sure? ('Y')").upcase == "Y"
            confirmed = true
        end
    end
    confirmed
end

def remove_known_hosts_entry(matching, remove_it=true)
    if remove_it
        `sed -i.bck '/#{matching}/d' ~/.ssh/known_hosts`
    end
end

def mask_message(message)
    @show_passwords ? message : "*****"
end

def get_image_id_and_hdd_device_path(provider, region, cloud_operating_system, get_hdd_device_path=true)
    avst_cloud_config_service = @conf.get_config("avst_cloud_config_service", false) || @global_config['avst_cloud_config_service']
    avst_cloud_config_service_username = @conf.get_config("avst_cloud_config_service_username", false) || @global_config['avst_cloud_config_service_username']
    avst_cloud_config_service_password = @conf.get_config("avst_cloud_config_service_password", false) || @global_config['avst_cloud_config_service_password']
    avst_cloud_config_file = @conf.get_config("avst_cloud_config_file", false)
    if get_hdd_device_path
        hdd_device_path = @conf.get_config("hdd_device_path", false)
    else
        hdd_device_path = "/dev/sda1"
    end
    image_id = @conf.get_config("image_id", false)

    unless hdd_device_path and image_id
        if avst_cloud_config_service
            # def get_server_image_template(provider, operating_system, region)
            url = URI.parse("#{avst_cloud_config_service}/server_identifier")
            params = {"provider" => provider, "region" => region, "operating_system" => cloud_operating_system}

            req = Net::HTTP::Get.new(url.request_uri)
            req.set_form_data( params )
            # if username and pass try with auth
            if (avst_cloud_config_service_username && avst_cloud_config_service_password)
                # setup auth
                req.basic_auth avst_cloud_config_service_username, avst_cloud_config_service_password
            end
            use_ssl = false
            if url.instance_of? URI::HTTPS
                use_ssl = true
            end
            begin
                response = Net::HTTP.start(url.host, url.port, use_ssl: use_ssl) { |http| http.request(req) }
                case response
                when Net::HTTPSuccess     then response.body
                else
                    raise "#{response.body} #{response.code.to_s}"
                end
            rescue Errno::ECONNREFUSED
                raise "ERROR: Connection refused while trying to connect to #{avst_cloud_config_service}/server_identifier"
            end
            @logger.debug(response.body.inspect)
            resp = JSON.parse(response.body)
            image_id = image_id || resp['image_name']
            hdd_device_path = hdd_device_path || resp['root_device_path']
        elsif avst_cloud_config_file
            file_config = YAML.load_file("#{avst_cloud_config_file}")
            if (file_config[provider][region] and file_config[provider][region] and file_config[provider][region][cloud_operating_system] and file_config[provider][region][cloud_operating_system]['image_name'])
                image_id = image_id || file_config[provider][region][cloud_operating_system]['image_name']
            end
            if (file_config[provider][region] and file_config[provider][region] and file_config[provider][region][cloud_operating_system] and file_config[provider][region][cloud_operating_system]['root_device_path'])
                hdd_device_path = hdd_device_path || file_config[provider][region][cloud_operating_system]['root_device_path']
            end
        end
    end
    return image_id, hdd_device_path
end


def create_rackspace_server(connection, server_name)
    @logger.debug("Creating server #{server_name} on Rackspace.")
    cloud_operating_system = @conf.get_config("cloud_operating_system")
    provider = connection.provider
    region = connection.region
    flavor_id = @conf.get_config("flavor_id", false) || 4
    image_id, hdd_device_path = get_image_id_and_hdd_device_path(provider, region, cloud_operating_system, false)
    connection.create_server(server_name, image_id, flavor_id) 
end

def create_aws_server(connection, server_name)
    @logger.debug("Creating server #{server_name} on AWS.")
    cloud_operating_system = @conf.get_config("cloud_operating_system")
    provider = connection.provider
    region = connection.region

    ami_image_id, hdd_device_path = get_image_id_and_hdd_device_path(provider, region, cloud_operating_system)
    
    mould                  = @conf.get_config("mould")
    key_name               = @conf.get_config("aws_key_name")
    ssh_key                = @conf.get_config("aws_ssh_key") 
    subnet_id              = @conf.get_config("aws_subnet_id")
    security_group_ids     = @conf.get_config("aws_security_group_ids")
    ebs_size               = @conf.get_config("aws_ebs_size", false)
    availability_zone      = @conf.get_config("aws_availability_zone")
    vpc                    = @conf.get_config("aws_vpc", false)
    created_by             = @conf.get_config("created_by", false) || Etc.getlogin
    connection.create_server(server_name, mould, cloud_operating_system, key_name, ssh_key, subnet_id, security_group_ids, ebs_size, hdd_device_path, ami_image_id, availability_zone, vpc, created_by)
end

def create_azure_server(connection, server_name)
    @logger.debug("Creating server #{server_name} on Azure.")
    cloud_operating_system = @conf.get_config("cloud_operating_system")
    provider = connection.provider
    region = @conf.get_config("region") || @global_config['region']
    unless region
        raise "Please provide location (region) of new Azure server."
    end
    azure_image_id, hdd_device_path = get_image_id_and_hdd_device_path(provider, region, cloud_operating_system)

    instance_type        = @conf.get_config("azure_instance_type", false)
    private_key_file     = @conf.get_config("azure_ssh_key", false)
    storage_account_name = @conf.get_config("azure_storage_account_name", false)
    user                 = @conf.get_config("root_user", false)
    connection.create_server(server_name, user, private_key_file, region, azure_image_id, instance_type, storage_account_name)
end

def destroy_azure_rm_server_and_resources(connection, server, server_name)
    resource_group = @conf.get_config("resource_group")
    virtual_network_resource_group = @conf.get_config("virtual_network_resource_group", false) || resource_group
    network_interface_resource_group = @conf.get_config("network_interface_resource_group", false) || virtual_network_resource_group
    network_interface = connection.find_network_interface_for_server(server_name, resource_group, false, network_interface_resource_group)
    storage_account_name = connection.find_storage_account_name_for_server(server_name, resource_group)
    azure_destroy_availability_set = @conf.get_config("azure_destroy_availability_set", false) == nil ? false : @conf.get_config("azure_destroy_availability_set", false)
    availability_set_name = connection.find_availability_set_name_for_server(server_name, resource_group, azure_destroy_availability_set)

    @logger.debug "About to detatch data_disks from #{resource_group}, #{storage_account_name}"
    data_disks = @conf.get_config("data_disks", false) || {}
    data_disks.keys.each do |disk_name|
        connection.detatch_data_disk(server_name, resource_group, storage_account_name, disk_name)
    end

    # destroy server
    server.destroy

    azure_destroy_network_interface = @conf.get_config("azure_destroy_network_interface", false) == nil ? false : @conf.get_config("azure_destroy_network_interface", false)
    @logger.debug "About to destroy network_interface #{azure_destroy_network_interface} and #{network_interface}"
    if azure_destroy_network_interface
        connection.destroy_network_interface(network_interface.name, network_interface_resource_group)
    end

    azure_destroy_public_ip_config = @conf.get_config("azure_destroy_public_ip_config", false) == nil ? false : @conf.get_config("azure_destroy_public_ip_config", false)
    @logger.debug "About to destroy public_ip_config #{azure_destroy_public_ip_config} and #{network_interface}"
    if azure_destroy_public_ip_config and network_interface and network_interface.public_ip_address_id
        ip_configuration_name = network_interface.public_ip_address_id.split("/")[-1]
        ip_configuration_resource_group = @conf.get_config("ip_configuration_resource_group", false) || network_interface_resource_group
        connection.destroy_ip_configuration(ip_configuration_name, ip_configuration_resource_group)
    end

    azure_destroy_virtual_network = @conf.get_config("azure_destroy_virtual_network", false) == nil ? false : @conf.get_config("azure_destroy_virtual_network", false)
    @logger.debug "About to destroy virtual_network #{azure_destroy_virtual_network} and #{network_interface}"
    if azure_destroy_virtual_network and network_interface and network_interface.subnet_id
        virtual_network_name = network_interface.subnet_id.split("virtualNetworks/")[-1].split("/")[0]
        connection.destroy_virtual_network(virtual_network_name, virtual_network_resource_group)
    end

    azure_destroy_storage_account = @conf.get_config("azure_destroy_storage_account", false) == nil ? false : @conf.get_config("azure_destroy_storage_account", false)
    @logger.debug "About to destroy storage_account #{azure_destroy_storage_account} and #{storage_account_name}"
    if azure_destroy_storage_account and storage_account_name
        storage_account_resource_group = @conf.get_config("storage_account_resource_group", false) || resource_group
        connection.destroy_storage_account(storage_account_name, storage_account_resource_group)
    end

    @logger.debug "About to destroy availability_set #{azure_destroy_availability_set} and #{availability_set_name}"
    if azure_destroy_availability_set and availability_set_name
        connection.destroy_storage_account(availability_set_name, resource_group)
    end

    azure_destroy_resource_group = @conf.get_config("azure_destroy_resource_group", false) == nil ? false : @conf.get_config("azure_destroy_resource_group", false)
    if azure_destroy_resource_group
        connection.destroy_resource_group(resource_group)
    end
end

def create_azure_rm_server(connection, server_name)
    @logger.debug("Creating server #{server_name} on Azure RM.")
    # cloud_operating_system = @conf.get_config("cloud_operating_system")
    provider = connection.provider
    
    publisher = @conf.get_config("publisher")
    offer = @conf.get_config("offer")
    sku = @conf.get_config("sku")
    version = @conf.get_config("version")
    platform = @conf.get_config("platform", false) || "Linux"
    user = @conf.get_config("root_user")
    password = @conf.get_config("password")
    location = @conf.get_config("location", false) || "West Europe"
    resource_group = @conf.get_config("resource_group")
    vm_size = @conf.get_config("vm_size", false)  || "Basic_A0"
    storage_account_name = @conf.get_config("storage_account_name", false) || "#{(server_name.gsub(/\W/,'') + 'stacc').downcase[0,23]}"
    storage_account_resource_group = @conf.get_config("storage_account_resource_group", false)
    connection.check_create_resource_group(storage_account_resource_group, location) if storage_account_resource_group

    availability_set_name = @conf.get_config("availability_set_name", false)
    
    network_interface_name = @conf.get_config("network_interface_name", false) || "#{(server_name.gsub(/\W/,'') + 'nic').downcase[0,23]}"
    network_interface_resource_group = @conf.get_config("network_interface_resource_group", false)
    connection.check_create_resource_group(network_interface_resource_group, location) if network_interface_resource_group

    virtual_network_name = @conf.get_config("virtual_network_name")
    virtual_network_resource_group = @conf.get_config("virtual_network_resource_group", false)
    connection.check_create_resource_group(virtual_network_resource_group, location) if virtual_network_resource_group

    subnet_name = @conf.get_config("subnet_name", false)
    subnet_resource_group = @conf.get_config("subnet_resource_group", false)

    ip_configuration_name = @conf.get_config("ip_configuration_name", false) || "#{(server_name.gsub(/\W/,'') + 'ipconf').downcase[0,23]}"
    ip_configuration_resource_group = @conf.get_config("ip_configuration_resource_group", false)
    connection.check_create_resource_group(ip_configuration_resource_group, location) if ip_configuration_resource_group
    
    create_public_ip_configuration = @conf.get_config("create_public_ip_configuration", false) == "false" || @conf.get_config("create_public_ip_configuration", false) == false ? false : true 
    
    private_ip_allocation_method = @conf.get_config("private_ip_allocation_method", false)
    public_ip_allocation_method = @conf.get_config("public_ip_allocation_method", false)
    subnet_address_list = @conf.get_config("subnet_address_list", false)
    dns_list = @conf.get_config("dns_list", false)
    network_address_list = @conf.get_config("network_address_list", false)
    address_prefix  = @conf.get_config("address_prefix", false)
    use_public_ip = @conf.get_config("use_public_ip", false) == nil ? true : @conf.get_config("use_public_ip", false)
    data_disks = @conf.get_config("data_disks", false) || {}
    connection.create_server(server_name, 
            user, 
            password,
            publisher,
            offer,
            sku,
            version, 
            platform,
            location, 
            resource_group, 
            vm_size, 
            storage_account_name, 
            network_interface_name, 
            virtual_network_name, 
            subnet_name, 
            ip_configuration_name, 
            private_ip_allocation_method,
            public_ip_allocation_method, 
            subnet_address_list, 
            dns_list, 
            network_address_list, 
            address_prefix,
            use_public_ip,
            create_public_ip_configuration,
            data_disks,
            availability_set_name,
            storage_account_resource_group,
            virtual_network_resource_group, 
            network_interface_resource_group, 
            ip_configuration_resource_group,
            subnet_resource_group)
end

def bootstrap_server(server, force, enable_passwordless_sudo, print_commands_only=false)
    server_name = server.server_name
    # domain and fqdn are overwritten for Vagrant below
    domain            = @conf.get_config("domain")
    fqdn              = "#{server_name}.#{domain}"
    
    as_user           = @conf.get_config('root_user', false) || server.access_user

    eyaml_private_key = @conf.hiera.config[:eyaml][:pkcs7_private_key]
    eyaml_public_key  = @conf.hiera.config[:eyaml][:pkcs7_public_key]

    unless File.exists?(eyaml_private_key) && File.exists?(eyaml_public_key)
        raise ("ERROR: Please ensure the eyaml public and private keys are configured and exist".red)
    end

    os                 = @conf.get_config('cloud_operating_system')
    bootstrap_template = @conf.get_config("bootstrap_template", false)
    
    # By default load file from config/bootstrap
    default_bootstrap_script = "#{File.expand_path("../../", __FILE__)}/config/bootstrap/#{os}.yaml.erb"
    bootstrap_file     = bootstrap_template || default_bootstrap_script

    custom_data = @conf.get_config("custom_data", false)

    bootstrap_yaml = {}
    if File.exists? bootstrap_file
        bootstrap_yaml = YAML.load(ERB.new(File.read(bootstrap_file)).result(binding))
    end

    bootstrap_templates_folders = @conf.get_config("extra_bootstrap_templates_folders", false)
    additional_pre_file_upload_commands = []
    additional_custom_file_uploads = {}
    additional_post_upload_commands = []
    if bootstrap_templates_folders
        bootstrap_templates_folders.each do |bootstrap_templates_folder|
            if File.directory?(bootstrap_templates_folder)
                @logger.debug "Adding yaml.erb files from #{bootstrap_templates_folder}"
                # List all files in the dir, order them and add each for post execution
                Dir["#{bootstrap_templates_folder}/*.yaml.erb"].sort.each do |f|
                    @logger.debug "Adding bootstrap commands from #{f}."
                    extra_conf = YAML.load(ERB.new(File.read(f)).result(binding))
                    additional_pre_file_upload_commands += extra_conf['pre_upload_commands'] if extra_conf['pre_upload_commands']
                    additional_custom_file_uploads.merge! extra_conf['custom_file_uploads'] if extra_conf['custom_file_uploads']
                    additional_post_upload_commands += extra_conf['post_upload_commands'] if extra_conf['post_upload_commands']
                    if extra_conf['failure']
                        raise "Required parameters missing in bootstrap template file #{f}: #{extra_conf['failure']}"
                    end
                end
            else
                @logger.warn "Skipping #{bootstrap_templates_folder} as it is not a directory."
            end
        end
    end

    extra_bootstrap_templates = @conf.get_config("extra_bootstrap_templates", false)
    if extra_bootstrap_templates
       extra_bootstrap_templates.each do |template|
            if File.file?(template)
                @logger.debug "Adding bootstrap commands from #{template}."
                extra_conf = YAML.load(ERB.new(File.read(template)).result(binding))
                additional_pre_file_upload_commands += extra_conf['pre_upload_commands'] if extra_conf['pre_upload_commands']
                additional_custom_file_uploads.merge! extra_conf['custom_file_uploads'] if extra_conf['custom_file_uploads']
                additional_post_upload_commands += extra_conf['post_upload_commands'] if extra_conf['post_upload_commands']
                if extra_conf['failure']
                    raise "Required parameters missing in bootstrap template file #{template}: #{extra_conf['failure']}"
                end
            else
                @logger.warn "Skipping #{template} as it is not a file."
            end
        end 
    end

    bootstrap_pre_upload_commands = @conf.get_config("bootstrap_pre_upload_commands", false)
    @logger.warn "Parameter bootstrap_pre_upload_commands will be deprecated, read documentation for usage patterns." if bootstrap_pre_upload_commands
    pre_upload_commands = bootstrap_pre_upload_commands || bootstrap_yaml['pre_upload_commands'] || []
    pre_upload_commands += additional_pre_file_upload_commands

    bootstrap_uploads = @conf.get_config("bootstrap_uploads", false)
    @logger.warn "Parameter bootstrap_uploads will be deprecated, read documentation for usage patterns." if bootstrap_uploads
    custom_file_uploads = bootstrap_uploads || bootstrap_yaml['custom_file_uploads'] || {}
    custom_file_uploads.merge! additional_custom_file_uploads

    bootstrap_post_upload_commands = @conf.get_config("bootstrap_post_upload_commands", false)
    @logger.warn "Parameter bootstrap_post_upload_commands will be deprecated, read documentation for usage patterns." if bootstrap_post_upload_commands
    post_upload_commands = bootstrap_post_upload_commands || bootstrap_yaml['post_upload_commands'] || []
    post_upload_commands += additional_post_upload_commands

    remote_server_debug = @conf.get_config("remote_server_debug", false) || false
    debug_structured_log = false

    @logger.debug "Pre upload bootstrap commands are: \n"
    pre_upload_commands.each do |c|
        @logger.debug c if c
    end
    @logger.debug "\n"
    @logger.debug "Custom bootstrap uploads are: \n"
    custom_file_uploads.each do |key, value|
        @logger.debug "#{key} => #{value}"
    end
    @logger.debug "\n"
    @logger.debug "Post upload bootstrap commands are: \n"
    post_upload_commands.each do |c|
        @logger.debug c if c
    end
    @logger.debug "\n"
    @logger.debug "Done printing bootstrap commands."

    unless print_commands_only
        server.bootstrap(pre_upload_commands, custom_file_uploads, post_upload_commands, remote_server_debug, debug_structured_log, enable_passwordless_sudo)
        @logger.debug "Done executing bootstrap commands."
    end
end


def provision_server(server, server_tmp_folder, avst_cloud_config_dir)
    # Provision params
    git    = @conf.get_config("git")
    branch = @conf.get_config("branch", false)
    reference = @conf.get_config("reference", false)
    puppet_runner = @conf.get_config("puppet_runner", false)
    puppet_runner_prepare = @conf.get_config("puppet_runner_prepare", false)
    custom_provisioning_commands = @conf.get_config("custom_provisioning_commands", false)
    destination_folder = nil
    server.provision(git, branch, server_tmp_folder, reference, custom_provisioning_commands, puppet_runner, puppet_runner_prepare, destination_folder, avst_cloud_config_dir)
end

def post_provision_commands(server, server_tmp_folder, print_commands_only=false)
    os = @conf.get_config('cloud_operating_system')
    remote_server_debug = @conf.get_config("remote_server_debug", false) || false
    skip_cleanup = @conf.get_config("skip_cleanup", false) || false
    custom_data = @conf.get_config("custom_data", false)

    extra_post_provision_templates_folders = @conf.get_config("extra_post_provision_templates_folders", false)
    additional_post_provision_commands = []
    if extra_post_provision_templates_folders
        extra_post_provision_templates_folders.each do |template_folder|
            if File.directory?(template_folder)
                @logger.debug "Adding yaml.erb files from #{template_folder}"
                Dir["#{template_folder}/*.yaml.erb"].sort.each do |f|
                    @logger.debug "Adding post provision commands from #{f}."
                    extra_conf = YAML.load(ERB.new(File.read(f)).result(binding))
                    additional_post_provision_commands += extra_conf['post_provision_commands'] if extra_conf['post_provision_commands']
                    if extra_conf['failure']
                        raise "Required parameters missing in post provision template file #{f}: #{extra_conf['failure']}"
                    end
                end
            else
                @logger.warn "Skipping #{template_folder} as it is not a directory."
            end
        end
    end

    extra_post_provision_templates = @conf.get_config("extra_post_provision_templates", false)
    if extra_post_provision_templates
       extra_post_provision_templates.each do |template|
            if File.file?(template)
                @logger.debug "Adding post provision commands from #{template}."
                extra_conf = YAML.load(ERB.new(File.read(template)).result(binding))
                additional_post_provision_commands += extra_conf['post_provision_commands'] if extra_conf['post_provision_commands']
                if extra_conf['failure']
                    raise "Required parameters missing in post provision template file #{template}: #{extra_conf['failure']}"
                end
            else
                @logger.warn "Skipping #{template} as it is not a file."
            end
        end 
    end

    custom_post_provision_commands = @conf.get_config('custom_post_provision_commands', false) || []
    custom_cleanup_commands = @conf.get_config('custom_cleanup_commands', false) || []
    custom_post_provision_commands += custom_cleanup_commands
    additional_post_provision_commands += custom_post_provision_commands
    @logger.debug "\n"
    @logger.debug "Post provision commands are: \n"
    additional_post_provision_commands.each do |c|
        @logger.debug c if c
    end

    @logger.debug "\n"
    @logger.debug "Done printing post provision commands."
    unless print_commands_only
        server.post_provisioning_commands(additional_post_provision_commands, os, remote_server_debug, server_tmp_folder, !skip_cleanup)
        @logger.debug "Done execiting post provision commands."
    end
end

def connect_to_server(connection, server_name, requires_root_access=true, require_public_ip=true)
    os = @conf.get_config('cloud_operating_system')
    provider = @conf.get_config('provider')
    root_user = @conf.get_config('root_user', false)
    root_password = nil
    enable_passwordless_sudo = false
    case provider
    when 'aws'
        if requires_root_access
            root_password = @conf.get_config('aws_ssh_key')
        end
        server = connection.server(server_name, root_user, root_password, os)
    when 'azure'
        if requires_root_access
            root_password = @conf.get_config('azure_ssh_key')
        end
        server = connection.server(server_name, root_user, root_password)
    when 'azurerm'
        if requires_root_access
            root_password = @conf.get_config('password')
        end
        enable_passwordless_sudo = true
        resource_group = @conf.get_config('resource_group')
        if require_public_ip
            use_public_ip = @conf.get_config('use_public_ip', false) == nil ? true : @conf.get_config('use_public_ip', false)

        else
            use_public_ip = false
        end
        if use_public_ip
            ip_configuration_resource_group = @conf.get_config('ip_configuration_resource_group', false)
        end

        network_interface_resource_group = @conf.get_config('network_interface_resource_group', false) 

        server = connection.server(server_name, resource_group, root_user, root_password, use_public_ip, network_interface_resource_group, ip_configuration_resource_group)
    when 'rackspace'
        if requires_root_access
            root_password = @conf.get_config('root_password')
        end
        server = connection.server(server_name, root_user, root_password, os)
    when 'none'
        ip_address = @conf.get_config("ip_address")
        root_password = @conf.get_config("root_password")
        server = AvstCloud::CloudServer.new(nil, server_name, ip_address, root_user, root_password)
    else
        raise "ERROR: Currently supported providers are: aws, azure and rackspeac.".red
    end
    return server, enable_passwordless_sudo
end

def test_config(server_name)
    provider = @conf.get_config('provider')
    splitted            = server_name.split("-")
    customer_short_code = splitted[0]
    env                 = splitted[1].gsub(/\d+/, '')
    server_number       = splitted[1].gsub(/[^\d]+/, '')
    bootstrap_file      = @conf.get_config("bootstrap_template", false) || "#{File.expand_path("../../", __FILE__)}/config/bootstrap/#{@conf.get_config('cloud_operating_system')}.yaml.erb"

    puts "Called test-config for #{server_name}".green
    puts "Provider:                  #{@conf.get_config('provider')}"
    puts "Provider user:             #{@conf.get_config('provider_username')}"
    puts "Provider pass:             #{mask_message(@conf.get_config('provider_password'))}"
    puts "Domain:                    #{@conf.get_config('domain', false)}"
    puts "Customer short code:       #{customer_short_code}"
    puts "Environment:               #{env}"
    puts "Server number:             #{server_number}"
    puts "Operating system:          #{@conf.get_config('cloud_operating_system')}"
    puts "eyaml private key:         #{@conf.hiera.config[:eyaml][:pkcs7_private_key]}"
    puts "eyaml public key:          #{@conf.hiera.config[:eyaml][:pkcs7_public_key]}"
    puts "Git repo:                  #{@conf.get_config('git', false)}"
    puts "Branch:                    #{@conf.get_config('branch', false)}"
    puts "Tag reference:             #{@conf.get_config('reference', false)}"
    puts "Bootstrap Script:          #{bootstrap_file}"
    puts "Extra bootstrap templates: #{@conf.get_config("extra_bootstrap_templates", false)}"
    puts "Extra bootstrap folders:   #{@conf.get_config("extra_bootstrap_templates_folders", false)}" 
    puts "Config Directory:          #{@avst_cloud_config_dir}"
    case provider
    when 'aws'
        puts "Region:                    #{@conf.get_config('region', false) || @global_config['region']}"
        puts "Connection SSH key         #{@conf.get_config('aws_ssh_key')}"
        puts "Subnet id:                 #{@conf.get_config("aws_subnet_id", false)}"
        puts "Security group ids:        #{@conf.get_config("aws_security_group_ids", false)}"
        puts "Availability zone:         #{@conf.get_config("aws_availability_zone", false)}"
        puts "AWS ebs size:              #{@conf.get_config('aws_ebs_size', false)} G"
    when 'azure'
        puts "Region:                    #{@conf.get_config('region', false) || @global_config['region']}"
        puts "Connection SSH key         #{@conf.get_config('azure_ssh_key')}"    
        puts "Instance type:             #{@conf.get_config("azure_instance_type", false)}"
        puts "Storage account name:      #{@conf.get_config("azure_storage_account_name", false)}"
    when 'azurerm'
        puts "Location:                  #{@conf.get_config('location', false) || "West Europe"}"
        puts "Connection SSH key         #{@conf.get_config('password')}"    
        puts "Instance type:             #{@conf.get_config("vm_size", false) || "Basic_A0"}"
        puts "Storage account name:      #{@conf.get_config("storage_account_name", false) || "#{(server_name.gsub(/\W/,'') + 'stacc').downcase[0,23]}"}"
        puts "Availability set name:     #{@conf.get_config("availability_set_name", false)}"
        puts "Virtual Network Name:      #{@conf.get_config("virtual_network_name")}"
        puts "Network Interface Name:    #{@conf.get_config("network_interface_name", false) || "#{(server_name.gsub(/\W/,'') + 'nic').downcase[0,23]}"}"
        puts "Subnet Name:               #{@conf.get_config("subnet_name", false)}"
        puts "IP Configuration Name:     #{@conf.get_config("ip_configuration_name", false) || "#{(server_name.gsub(/\W/,'') + 'ipconf').downcase[0,23]}"}"
        puts "Private IP Alloc Method:   #{@conf.get_config("private_ip_allocation_method", false)}"
        puts "Public IP Alloc Method:    #{@conf.get_config("public_ip_allocation_method", false)}"
        puts "Subnet Address List:       #{@conf.get_config("subnet_address_list", false)}"
        puts "DNS List:                  #{@conf.get_config("dns_list", false)}"
        puts "Network Addres List:       #{@conf.get_config("network_address_list", false)}"
        puts "Address Prefix:            #{@conf.get_config("address_prefix", false)}"
        puts "Use Public IP:             #{@conf.get_config("use_public_ip", false)}"
        puts "Destroy Network Interface: #{@conf.get_config("azure_destroy_network_interface", false) == nil ? false : @conf.get_config("azure_destroy_network_interface", false)}"
        puts "Destroy Public IP:         #{@conf.get_config("azure_destroy_public_ip_config", false) == nil ? false : @conf.get_config("azure_destroy_public_ip_counfig", false)}"
        puts "Destroy Virtual Network:   #{@conf.get_config("azure_destroy_virtual_network", false) == nil ? false : @conf.get_config("azure_destroy_virtual_network", false)}"
        puts "Destroy Storage Account:   #{@conf.get_config("azure_destroy_storage_account", false) == nil ? false : @conf.get_config("azure_destroy_storage_account", false)}"
        puts "Destroy Resource Group:    #{@conf.get_config("azure_destroy_resource_group", false) == nil ? false : @conf.get_config("azure_destroy_resource_group", false)}"
        puts "Azure OS Image:            #{@conf.get_config("publisher")} #{@conf.get_config("offer")} #{@conf.get_config("sku")} #{@conf.get_config("version")}"
        puts "Data disks:                #{@conf.get_config("data_disks", false) || {}}"
    when 'rackspace'
        puts "Region:                    #{@conf.get_config('region', false) || @global_config['region'] || :lon}"
        puts "Root password:             #{mask_message(@conf.get_config('root_password', false))}"
    when 'none'
        puts 'Connecting directly to server:'
        puts "ip_address:                #{@conf.get_config('ip_address')}"
        puts "Root user:                 #{@conf.get_config('root_user')}"
        puts "Root password:             #{mask_message(@conf.get_config('root_password'))}"
    else
        raise "ERROR: Currently supported providers are: aws, azure, azure-rm and rackspace.".red
    end
end

start_time = Time.now

begin
  options = Docopt::docopt(doc)
rescue Docopt::Exit => e
  abort(e.message)
end
@logger = Logger.new($stdout)
@global_config = {}
if File.exists? ("#{ENV['HOME']}/.avst-cloud.yaml")
    @global_config = YAML.load(File.read("#{ENV['HOME']}/.avst-cloud.yaml")) || {}
end

begin
    server_config_url = options["--server_config_url"]
    if server_config_url =~ URI::regexp
        # in case it is url download the config
        url = URI.parse("#{server_config_url}")
        req = Net::HTTP::Get.new(url.request_uri)
        server_config_username = options["--server_config_url_username"] || @global_config['server_config_url_username']
        server_config_password = options["--server_config_url_password"] || @global_config['server_config_url_password']
        if server_config_username and server_config_password
            # setup auth
            req.basic_auth server_config_username, server_config_password
        else
            puts "service config provided but --server_config_url_username and --server_config_url_password missing, trying withouth auth."
        end

        use_ssl = false
        if url.instance_of? URI::HTTPS
            use_ssl = true
        end
        response = Net::HTTP.start(url.host, url.port, use_ssl: use_ssl) { |http| http.request(req) }

        # we expect yaml file that represents avst-cloud configuration
        # store it to custom_config
        
        if response.kind_of? Net::HTTPSuccess and response.body != ""
            begin
                server_config_yaml = YAML.load(response.body)
            rescue YAML::ParserError => e
                raise ("ERROR: Passed config is not a valid yaml. #{response.body}")
            end
        else
            raise ("Configuration via service not found: #{server_config_url}")
        end
    end

    custom_config = options["--custom_config"]
    # create custom config in case it is defined
    if custom_config
        begin
            custom_config = JSON.parse(custom_config)
        rescue JSON::ParserError => e
            raise ("ERROR: Passed config is not a valid json. #{custom_config}")
        end
        server_name = custom_config['server_name']
        unless server_name and (/^\w+-\w+\d+$/ =~ server_name.downcase)
           puts("WARN: Valid server_name not provided in custom_config, Will try options... See the help for details".yellow)    
        else
            splitted = server_name.split("-")
            custom_config['client'] = splitted[0]
        end
        # for avst-cloud hiera config
        if server_config_yaml
            server_config_yaml = server_config_yaml.merge custom_config
        else
            server_config_yaml = custom_config
        end
    end

    custom_config_per_run = nil
    if server_config_yaml
        custom_config_per_run = "custom_config_#{Time.now.to_i}_#{[*('a'..'z')].shuffle[0,8].join}"
        custom_config_per_run_file = "config/hiera/#{custom_config_per_run}.yaml"
        File.open(custom_config_per_run_file, 'w') {|f| f.write server_config_yaml.to_yaml }
        # as custom facts that will be passed to server 
        # must pass client, mapped_hostname, host_<application_type> or puppet will fail
        File.open('config/custom_system_config/environments/production/modules/hosts/facts.d/facts.yaml', 'w') {|f| f.write server_config_yaml.to_yaml }
    end

    force              = options["--force"]
    do_not_log         = options["--no-report"]
    remove_known_hosts = options["--remove-known-hosts"]
    hiera_config       = options["--hiera_config"]

    unless server_name
        # Validation
        unless options["<server-name>"] and (/^\w+-\w+\d+$/ =~ options["<server-name>"].downcase)
            raise ("ERROR: Please provide a valid server name. See the help for details".red)
        end
        server_name = options["<server-name>"].downcase
    end

    # Configuration checking
    splitted            = server_name.split("-")
    customer_short_code = splitted[0]
    env                 = splitted[1].gsub(/\d+/, '')
    server_number       = splitted[1].gsub(/[^\d]+/, '')

    scope = {
      "::server_name"         => server_name,
      "::env"                 => env,
      "::customer_short_code" => customer_short_code,
    }

    # if there is a custom data dir use it, otherwise use base
    avst_cloud_config_dir = options["--config_dir"] || @global_config['config_dir'] || "#{avst_cloud_base}/config"
    @avst_cloud_config_dir = avst_cloud_config_dir

    # create fully qualified hiera.yaml based on template, to be able to refer to config/hiera
    unless hiera_config
        hiera_config = "#{avst_cloud_base}/hiera.yaml"
        hiera_config_template = File.read("#{avst_cloud_base}/templates/hiera.yaml.erb")
        File.open("#{hiera_config}", 'w') do |f|
            f.write ERB.new(hiera_config_template, nil, '%<>-').result(binding)
        end
    end

    @conf = HieraLoader.new(scope, hiera_config)

    # parse conf from hiera
    provider = @conf.get_config("provider").downcase

    do_not_log = do_not_log || ( @conf.get_config("no_report", false) == 'true')
    unless do_not_log || options['test-config']  || options['status']
        puts "Setting confluence logger as default logger".green
        conf_base_url        = @conf.get_config("confluence_url", false) || @global_config['confluence_url']
        conf_user            = @conf.get_config("confluence_user", false) || @global_config['confluence_user']
        conf_pass            = @conf.get_config("confluence_access_password", false) || @global_config['confluence_access_password']
        conf_space           = @conf.get_config("confluence_space", false) || @global_config['confluence_space']
        conf_parrent_page_id = @conf.get_config("confluence_parent_page_id", false) || @global_config['confluence_parent_page_id']
        unless conf_base_url and conf_user and conf_pass and conf_space and conf_parrent_page_id
            raise "Please provide confluence reporter configuration. Provided: URL: #{conf_base_url} User: #{conf_user} Pass: #{conf_pass} Space #{conf_space} Page_id #{conf_parrent_page_id}"
        end
        confl_logger = ConfluenceReporter::Reporter.new(conf_base_url, conf_user, conf_pass) 
    end

    provider_user = @conf.get_config("provider_username", false) || @global_config['provider_username']
    provider_pass = @conf.get_config("provider_password", false) || @global_config['provider_password']

    if provider != 'none'
        unless provider_user and provider_pass
            raise "Please provide provider credentials and region. Provided: User #{provider_user}, Pass #{provider_pass}"
        end
    end
    
    case provider
    when 'aws'
        region = @conf.get_config("region", false) || @global_config['region']
        unless region
            raise "Please provide region. Provided: Region #{region}"
        end
        require 'avst-cloud/aws_connection'
        require 'avst-cloud/aws_server'
        connection = AvstCloud::AwsConnection.new(provider_user, provider_pass, region)
    when 'azure'
        require 'avst-cloud/azure_connection'
        require 'avst-cloud/azure_server'
        provider_api_url = @conf.get_config("provider_api_url", false) || @global_config['provider_api_url']
        connection = AvstCloud::AzureConnection.new(provider_user, provider_pass, provider_api_url)
    when 'rackspace'
        require 'avst-cloud/rackspace_connection'
        require 'avst-cloud/rackspace_server'
        region = @conf.get_config("region", false) || @global_config['region'] || :lon
        connection = AvstCloud::RackspaceConnection.new(provider_user, provider_pass, region)
    when 'azurerm'
        require 'avst-cloud/azure_rm_connection'
        require 'avst-cloud/azure_rm_server'
        tenant_id = @conf.get_config("tenant_id")
        subscription_id = @conf.get_config("subscription_id")
        connection = AvstCloud::AzureRmConnection.new(provider_user, provider_pass, tenant_id, subscription_id)
    when 'none'
        # when provider is nil, connection not needed, only bootstrap, provision and cleanup commands are allowed
        connection = nil
    else
        raise "ERROR: Currently supported providers are: azure, azurerm aws and rackspace.".red
    end
    
    @logger = confl_logger ? confl_logger : Logger.new($stdout)
    require 'avst-cloud/logging'
    Logging.logger = @logger
    @show_passwords = options["--show_passwords"] || @conf.get_config("show_passwords", false) || false
    Logging.show_passwords = @show_passwords

    has_errors=false
    dry = options['--dry'] || false

    if options['all']
        @logger.debug("Called all".green)
        test_config(server_name)
        confirmed = confirm("Are you sure you want to create server #{server_name}?", force)
        if confirmed
            enable_passwordless_sudo = false
            case provider
            when 'aws'
                server = create_aws_server(connection, server_name)
            when 'azure'
                server = create_azure_server(connection, server_name)
            when 'azurerm'
                enable_passwordless_sudo = true
                server = create_azure_rm_server(connection, server_name)
            when 'rackspace'
                server = create_rackspace_server(connection, server_name)
            else
                server, enable_passwordless_sudo = connect_to_server(connection, server_name)
            end
            bootstrap_server(server, force, enable_passwordless_sudo)
            avst_cloud_tmp_folder = @conf.get_config("avst_cloud_tmp_folder", false) || "/tmp/avst_cloud_tmp_#{Time.now.to_i}"
            provision_server(server, avst_cloud_tmp_folder, avst_cloud_config_dir)
            post_provision_commands(server, avst_cloud_tmp_folder)
            
        else
            @logger.debug("Not creating server, you have to confirm.".yellow)
        end 
    elsif options['create']
        @logger.debug("Called create".green)
        test_config(server_name)
        confirmed = confirm("Are you sure you want to create server #{server_name}?", force)
        if confirmed
            case provider
            when 'aws'
               server = create_aws_server(connection, server_name)
            when 'azure'
               server = create_azure_server(connection, server_name)
            when 'azurerm'
               server = create_azure_rm_server(connection, server_name)
            when 'rackspace'
                server = create_rackspace_server(connection, server_name)
            else
                raise "You can create server only for AWS, Azure and Rackspace provider"
            end
        else
            @logger.debug("Not creating server, you have to confirm.".yellow)
        end
    elsif options['clean']
        @logger.debug("Called clean with only print commands set to: #{dry}".green)
        avst_cloud_tmp_folder = @conf.get_config("avst_cloud_tmp_folder", false) || "/tmp/avst_cloud_tmp_#{Time.now.to_i}"
        # In case it is default with timestamp remove all
        if (avst_cloud_tmp_folder =~ /\/tmp\/avst_cloud_tmp_/)
            avst_cloud_tmp_folder = "/tmp/avst_cloud_tmp_*"
        end
        server, enable_passwordless_sudo = connect_to_server(connection, server_name)
        post_provision_commands(server, avst_cloud_tmp_folder, dry)
        @logger.debug("Clean done".green)
    elsif options['test-config']
        do_not_log = true
        test_config(server_name)
    elsif options['start']
        @logger.debug("Called start".green)
        raise "Unsupported operation for provider none" if provider == 'none'
        confirmed = confirm("Are you sure you want to start server #{server_name}?", force)
        if confirmed
            server, enable_passwordless_sudo = connect_to_server(connection, server_name, false, false)
            server.start
        else
            @logger.debug("Not starting server.".yellow)
        end
    elsif options['stop']
        @logger.debug("Called stop".green)
        raise "Unsupported operation for provider none" if provider == 'none'
        confirmed = confirm("Are you sure you want to stop server #{server_name}?", force)
        if confirmed
            # Rackspace stop of server is done via ssh command execution as it does not supports stop
            requires_root_access = provider == 'rackspace' ? true : false
            server, enable_passwordless_sudo = connect_to_server(connection, server_name, requires_root_access, requires_root_access)
            server.stop
            server_ip_addr = server.ip_address
            if server_ip_addr
                remove_known_hosts_entry(server_ip_addr, remove_known_hosts)
            end
        else
            @logger.debug("Not stopping server.".yellow)
        end
    elsif options['status']
        do_not_log = true
        @logger.debug("Called status".green)
        raise "Unsupported operation for provider none" if provider == 'none'
        if provider == "azurerm"
            resource_group = @conf.get_config("resource_group")
            connection.server_status(server_name, resource_group)
        else
            connection.server_status(server_name)
        end
    elsif options['destroy']
        @logger.debug("Called destroy".green)
        raise "Unsupported operation for provider none" if provider == 'none'
        confirmed = confirm("Are you sure you want to destroy server #{server_name}?", force)
        if confirmed 
            server, enable_passwordless_sudo = connect_to_server(connection, server_name, false, false)
            server_ip_addr = server.ip_address
            if provider == "azurerm"
                destroy_azure_rm_server_and_resources(connection, server, server_name)
            else
                server.destroy
            end
            if server_ip_addr
                remove_known_hosts_entry(server_ip_addr, remove_known_hosts)
            end
        else
            @logger.debug("Not destroying server as you did not confirm it.".yellow)
        end
    elsif options['provision']
        @logger.debug("Called provision".green)
        server, enable_passwordless_sudo = connect_to_server(connection, server_name)
        avst_cloud_tmp_folder = @conf.get_config("avst_cloud_tmp_folder", false) || "/tmp/avst_cloud_tmp_#{Time.now.to_i}"
        provision_server(server, avst_cloud_tmp_folder, avst_cloud_config_dir)
    elsif options['bootstrap']
        @logger.debug("Called bootstrap with only print commands set to: #{dry}".green)
        server, enable_passwordless_sudo = connect_to_server(connection, server_name)
        bootstrap_server(server, force, enable_passwordless_sudo, dry)
        @logger.debug("Bootstrap done".green)
    elsif options['find_server']
        do_not_log = true
        @logger.debug("Called find".green)
        raise "Unsupported operation for provider none" if provider == 'none'
        connection.find_server(server_name).inspect
    else
        do_not_log = true
        raise ("ERROR: Please provide a valid command".red)
    end

# In case something went wrong on the way
rescue Exception => e
    message = e.message.force_encoding("utf-8")
    @logger.error("Something went wrong: #{message}")
    e.backtrace.each do |err|
        @logger.error(err)
    end
    has_errors=true
end

if custom_config_per_run
    File.delete(custom_config_per_run_file)
end

unless do_not_log
    @logger.debug("Reporting progress".green)
    begin
        if @logger.methods.include? :report_event
            @logger.report_event(server_name, conf_parrent_page_id, conf_space)
        else
            @logger.debug("Can not report event, logger is ruby standard Logger not Confluence reporter or it does not respond to report_event method".yellow)
        end
    rescue Exception => e
        @logger.debug(e.message.yellow)
    end
end

if has_errors
    abort "Process failed with error: #{message}".red
end

time_taken = ((Time.now - start_time) / 60).round(2)
@logger.debug("Finished in #{time_taken} minutes".green)
